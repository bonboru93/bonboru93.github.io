<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bonboru93.github.io</id>
    <title>Bonboru93の</title>
    <updated>2021-05-28T05:45:49.622Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bonboru93.github.io"/>
    <link rel="self" href="https://bonboru93.github.io/atom.xml"/>
    <subtitle>この片隅に</subtitle>
    <logo>https://bonboru93.github.io/images/avatar.png</logo>
    <icon>https://bonboru93.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bonboru93の</rights>
    <entry>
        <title type="html"><![CDATA[宅家玩魔改u]]></title>
        <id>https://bonboru93.github.io/post/zhai-jia-wan-mo-gai-u/</id>
        <link href="https://bonboru93.github.io/post/zhai-jia-wan-mo-gai-u/">
        </link>
        <updated>2021-05-28T05:35:08.000Z</updated>
        <content type="html"><![CDATA[<p>很早就听说了华强北魔改u的神奇操作，也暗戳戳的提前翻了几篇自己动手改bios加微码支持魔改u的教程，想着正好把家里几年前压箱底的一块主板和两根内存翻出来废物利用。</p>
<figure data-type="image" tabindex="1"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/cpu.jpg" alt="" loading="lazy"></figure>
<p>又正好最近刚仔仔细细的看了一遍dortania的opencore tutorial，感叹现在的黑果再没那么复杂了，有了SSDTTime、lilu、whatevergreen这些工具，就不用像从前一样没完没了的适配了，在老笔电上先试了下也一次成功。</p>
<p>所以要是成功组起来的话，硬改+软改，改上改，岂不是牛逼坏了。</p>
<p>可惜最近矿潮，显卡搞不定了，只能用用核显。压箱底的b250主板没有dp口，没法用4k，我反正是回不去1080p了。而且更要命的是这板子是d4的，找出来的内存偏偏是d3。这么一来废物利用没戏了。</p>
<p>又不死心，在b站找了最近玩魔改比较狂的up主图吧之花七七，搞到了一套z170+qqls的板u套装回来折腾。毕竟魔改i9，16个框框，还是挺唬人的。（<s>疯狂加钱</s>）</p>
<figure data-type="image" tabindex="2"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/qq.jpg" alt="" loading="lazy"></figure>
<p>到手看着还是很舒服的，itx的板子小小一个，散热器也很精致的亚子。</p>
<p>没想到后面的事情远没有那么简单QQ</p>
<h1 id="到手">到手</h1>
<p>到手开机一次点亮，看bios发现七七超了CPU，拉高了电压和功耗墙，动了内存时序，固定了内存频率到1600。</p>
<figure data-type="image" tabindex="3"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/bios1.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/bios2.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/bios3.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/bios4.jpg" alt="" loading="lazy"></figure>
<p>还原了bios之后发现就点不亮了，一番测试发现是内存频率的锅，超过1600就点不亮了，可能是魔改u的问题。这个倒是还好，差一点无所谓，不过要记得备一条默频低于1600的内存，不然哪天bios没电了就gg了。还好七七姐送了一条测试条给我，暖。</p>
<p>然后还是先装个win，大概看了看没啥问题。然后把DSDT撸下来。开始做黑果的安装盘。</p>
<h1 id="装黑果">装黑果</h1>
<p>第一遍还是严格按手册来，有点不太确定的是这个笔记本u魔改出来的到底算desktop还是laptop，决定先按desktop的来，有问题的了再对比看laptop改了什么。</p>
<p>整好检查一遍开始上机，结果报这个错：</p>
<figure data-type="image" tabindex="7"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/bug.jpg" alt="" loading="lazy"></figure>
<p>刚开始起不来也正常，这时候还不慌。</p>
<p>首先看最终是panic了，所以应该是死在kernel。</p>
<p>kernel dump之前有ACPI Error，但不确定是不是导致panic的直接原因，dump到最后只有地址，没有给出函数名，不好判断。</p>
<p>决定先查ACPI的问题。</p>
<p>从报错信息上看，是RHUB下的HS11端口未定义，也就是说是USB的问题。</p>
<p>先把USBInjectAll删掉试试，不行。</p>
<p>把XHCIPortLimit去掉试试，不行。</p>
<figure data-type="image" tabindex="8"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/xhci1.png" alt="" loading="lazy"></figure>
<p>尝试这个XHCI-unsupported，不行。</p>
<figure data-type="image" tabindex="9"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/xhci2.png" alt="" loading="lazy"></figure>
<p>对比laptop平台和desktop平台，发现有这么一个quirk的不同，感觉就是这个问题了，还是不行。</p>
<figure data-type="image" tabindex="10"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/rhub.png" alt="" loading="lazy"></figure>
<p>再尝试查和RHUB有关的fix，发现了这个SSDT，感觉也很接近问题的本源了，还是不行。</p>
<figure data-type="image" tabindex="11"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/panic1.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/panic2.png" alt="" loading="lazy"></figure>
<p>暂且不管ACPI的问题，直接查kernel issue，看是不是和boot的quirk有关，尝试了这三项的各种组合，结果都还是不行。</p>
<figure data-type="image" tabindex="13"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/dsdt.png" alt="" loading="lazy"></figure>
<p>最终还是绕回来看ACPI的问题，报错的是HS11未定义，从DSDT里看，HS11的定义是放在一个if里面，会不会是因为这个if不成立呢。查表看PCHV和SPTH都是有的，值也是对的。讲道理不应该。</p>
<p>不过也有看到某个帖子说这个global的if会被放在最后才执行，如果之前就引用了就可能有错。</p>
<p>没搞过bios真是抓瞎，也怪之前上班摸鱼的时候只是简单翻了一遍ACPI spec，没有认真学习，现在只能猜测然后尝试了。</p>
<p>自己动手把这一串RHUB下的定义复制一份放到if的外面，还是失败了。</p>
<figure data-type="image" tabindex="14"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/ssdt.png" alt="" loading="lazy"></figure>
<p>再想，不去动定义的部分，改一改引用的地方可不可以，毕竟这几个端口可以不用。</p>
<p>把opencore的sysReport打开，把DSDT连同所有的SSDT全部dump出来，在SSDT-6这张表里面看到了报错的xh_rvp08这个表名，里面全是RHUB下的端口定义。</p>
<p>尝试删掉HS11，无效。</p>
<figure data-type="image" tabindex="15"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/rvp08.png" alt="" loading="lazy"></figure>
<p>尝试直接写ACPI配置下的的block部分，把整张xh_rvp08表给干掉。</p>
<p>这下倒是没再报ACPI Error了，不过还是死在了kernel panic。</p>
<p>再一看usb鼠标键盘都断电了，看样子是打击面太大了。</p>
<p>仰天长叹啊，没想到最终还是到了四处乱翻论坛和社区的阶段，和黑果有关的几篇帖子的解法都没用，一堆linux下的问题倒是乱入了不少，我甚至还查了查bsd有没有kdump之类的工具，能让我看看最后挂的这两个地址到底是啥函数。</p>
<p>╮(╯▽╰)╭搞得休假跟上班一样。</p>
<figure data-type="image" tabindex="16"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/d.png" alt="" loading="lazy"></figure>
<p>最后放弃治疗，认同上面这个帖子的意见，还是魔改bios的问题可能性大一些，为了支持多核和超线程，搞乱了一些东西，将来有机会做bios再研究吧QQ</p>
<h1 id="没想到win也有问题">没想到win也有问题</h1>
<p>无奈老老实实用回win了，虽然很不甘心。这么多年了，win肯定又多了不少脏东西了，又要花时间去整，烦人。</p>
<p>没想到还没开始折腾，就发现了一个更要命的问题。</p>
<p><strong>4k输出间歇性黑屏</strong></p>
<p>刚到手的时候先接的老屏幕做测试，所以没发现。</p>
<p>尝试换一条dp1.4的线，无效。</p>
<p>尝试套一个屏蔽环，无效。</p>
<p>尝试调30hz，似乎有点好转，不过还是会闪。</p>
<figure data-type="image" tabindex="17"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/4k.jpg" alt="" loading="lazy"></figure>
<p>查到可能还是和魔改u有关系，联想到之前高频内存点不亮，越看越像这个人描述的问题。</p>
<p>最后只能是退机了QQ</p>
<h1 id="再换一台试试">再换一台试试！</h1>
<p>实在是不甘心就这么没玩成，所以又摸了一个新玩具</p>
<figure data-type="image" tabindex="18"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/m710.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/m710-spec.jpg" alt="" loading="lazy"></figure>
<p>1L的小主机，不过还是带的魔改u，有dp口，wifi蓝牙也都有，而且关键是有看到同型号黑果成功的帖子了，感觉安心。</p>
<p>结果搞回来以后发现win下4k还是间歇性黑屏，天哪简直是简直了，魔改是和4k有仇的么！</p>
<p>不死心，还是先撸个黑果看看，说不定黑果下不黑屏呢。</p>
<h1 id="黑果again">黑果again</h1>
<p>这台搞下来倒是没有费太大的力气，唯一值得说一下的就是显存预分配的问题。</p>
<figure data-type="image" tabindex="20"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/mem.png" alt="" loading="lazy"></figure>
<p>第一次上机卡在最后要进GUI的位置，猜测是显卡相关的问题。</p>
<p>试着压低显存stolen的量就顺利进入安装界面了。</p>
<p>不过装好之后没有4k输出，最高只到2k，猜测是预分配的量压的太低，不够4k的缓冲帧。</p>
<figure data-type="image" tabindex="21"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/stole.png" alt="" loading="lazy"></figure>
<p>之所以压低了之后可以进系统是因为UHD630在mac下默认缓冲帧大小的是57MB，超过了bios分配的值。压低了之后虽然能进系统，但出不了4k了。</p>
<p>第一遍翻bios的时候没有看到能调预分配显存的地方，这种品牌机的bios都很简陋，这也正常。</p>
<p>难不成又要开始新一轮的折腾？找卖家要bios自己动手改？</p>
<p>想想就头大，不过还好，又仔细的翻了一遍发现，在video option中先把输出类型从auto改成IGD之后，预分配显存的选项就出来了。</p>
<p>真TM搞笑，根本就没独显还要来这么一出，不过总算是皆大欢喜。调大到64MB之后，就可以去掉stolenmem的调整，直接用platform-id就能驱动了，型号也不需要仿冒。</p>
<h1 id="wifi的问题">wifi的问题</h1>
<p>卖家带的网卡是intel的7260ac，印象中之前intel无线网卡在黑果下都是无解的。</p>
<figure data-type="image" tabindex="22"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/intel.png" alt="" loading="lazy"></figure>
<p>不过最近似乎也是有了社区版驱动了。</p>
<p>试用了一下在big sur下2.4G不可用，5G勉强可以，蓝牙不可用。</p>
<p>看了下这个驱动是和系统有关的，重装mojave之后有好转，2.4G勉强可以，5G完全可用，蓝牙勉强可以。</p>
<figure data-type="image" tabindex="23"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/anta.jpg" alt="" loading="lazy"></figure>
<p>拆机发现，网卡上接的是一个外置天线，一个贴片天线，这个贴片天线实在是过于简陋了。。。</p>
<p>两根天线调换过来的话，蓝牙就可用了。不过2.4G又不行了哈哈哈哈，应该是这个垃圾贴片天线的问题了。</p>
<p>重新买了个外置天线，中间还买错了，不知道IPEX的接头有1型和4型，又是几天的折腾。</p>
<p>然后这个机箱后面没有第二个天线接口，不过有预留了两个十字口子，可以从外面接天线进来，然后用热熔胶固定，搞定～</p>
<figure data-type="image" tabindex="24"><img src="https://bonboru93.github.io/post-images/zhaijia-mogai/anta2.jpg" alt="" loading="lazy"></figure>
<h1 id="后记">后记</h1>
<p>珍惜这段装在盒子里的时间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[时间轮算法]]></title>
        <id>https://bonboru93.github.io/post/shi-jian-lun-suan-fa/</id>
        <link href="https://bonboru93.github.io/post/shi-jian-lun-suan-fa/">
        </link>
        <updated>2021-03-01T10:42:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>做定时器其实就是让你维护一个有序数据结构，除了用插入排序、二叉堆之类的去搞以外，哈希桶也是一种办法。</p>
<p>时间轮其实就是一种哈希桶的变种。</p>
<figure data-type="image" tabindex="1"><img src="https://bonboru93.github.io/post-images/time-wheel/simple.jpg" alt="" loading="lazy"></figure>
<p>最朴素的搞法就是一个哈希桶，两头串起来，变成哈希环。</p>
<p>定时器根据超时时间的不同，挂到哈希环上对应的格子里去。看上面的图就表示第1秒有2个任务超时，第3秒有3个任务超时。</p>
<p>然后有一个指针在环上不停的去转，取下经过的格子里的任务去执行。</p>
<p>单单是这样的话没法应对很大的时间范围，因为哈希桶要吃内存。</p>
<p>所以我们想到了真实的时钟：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/real.png" alt="" loading="lazy"><br>
这看起来就像是一个只有60个小格和12个大格的哈希环，每个小格是1秒，大格是1小时。但是通过【时】【分】【秒】这3个指针的组合却表示了12*60*60秒的时间范围。</p>
<p>这就启发我们可以模仿真实的时钟来级联多个时间轮，在有限的空间内表示大范围的时间。</p>
<h1 id="实例说明">实例说明</h1>
<p>这里我们就完全模仿真实的时钟，来做一个demo用时间轮。</p>
<p>可以看到，时钟上有【时】【分】【秒】三个指针，</p>
<p>秒针一圈60格，转一圈是1分钟，带动分针走一格，</p>
<p>分针一圈60格，转一圈是1小时，带动时针走一格，</p>
<p>时针一圈12格，转一圈是半天，然后重新开始。</p>
<p>时钟最大表示12小时，最小精度为1秒。</p>
<p>区别于真实的时钟在同一个表盘上重叠时针、分针和秒针，我们需要3个独立的表盘来分别表示时、分和秒，你可以想象我们把真实的时钟做了z轴上的拆解。</p>
<p>别忘了时间轮是一种定时器，我们不光要知道现在几点，还要知道在未来的某个时间点上有哪些任务。</p>
<p>所以具体到数据结构上，是3个环：</p>
<ul>
<li>秒针环长60，保存在未来60秒内超时的任务</li>
<li>分针环长60，保存在未来60分钟内超时的任务</li>
<li>时针环长12，保存在未来12小时内超时的任务</li>
</ul>
<p>画出来的话就长这个样子，假设一开始是0时0分0秒：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/000.png" alt="" loading="lazy"><br>
接着我们来加任务，举几个栗子：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>0时0分24秒</td>
<td>task1</td>
</tr>
<tr>
<td>0时18分46秒</td>
<td>task2</td>
</tr>
<tr>
<td>2时30分45秒</td>
<td>task3</td>
</tr>
<tr>
<td>2时50分9秒</td>
<td>task4</td>
</tr>
<tr>
<td>2时50分10秒</td>
<td>task5</td>
</tr>
</tbody>
</table>
<p>来看添加完以后，整个时间轮的样子：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/fulltask.png" alt="" loading="lazy"><br>
就像我们说好的那样，未来60秒内超时的task1放在了秒针环，未来60分钟超时的task2放在了分针环，未来12小时超时的task3～5放在了时针环，有task的格子会标红。</p>
<p>如果你暂时不理解为什么这么放，接着看，我们让时间轮转起来就好懂了。</p>
<p>好了，可以让时间轮转起来了，<strong>就像真正的时钟一样</strong>。</p>
<p>当经过了24秒，也就是秒针走到第24格时，我们惊喜的发现这一格里有一个task1，于是我们把他摘下来执行，这时候时间轮的样子：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task1.png" alt="" loading="lazy"><br>
摸鱼的时间总是过得很快，转眼就发呆了18分钟了，我们发现分针的第18格里有东西，快把他摘下来。</p>
<p>但不能立即执行他，别忘了我们的定时器精度是1秒呢，人家明明白白的写了要0时18分46秒的时候才能执行。</p>
<p>怎么办？只好把他再放到秒针环链表上第46格的位子，让秒针去走过这46秒，这样才能准确到1秒嘛：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task2_move.png" alt="" loading="lazy"><br>
接下来你应该猜到了，打了个水回来，正好就用了46秒，boom，task2触发：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task2.png" alt="" loading="lazy"><br>
只有分针和秒针还不够，我们的定时器说好了要保存12小时以内的超时事件的。</p>
<p>所以时针也要用起来呀，于是我们安插了3个两个多小时才超时的task3～5。</p>
<p>当然了，这次要让时钟快转2个小时，到我们要演示的地方：</p>
<p><img src="https://bonboru93.github.io/post-images/time-wheel/2h.png" alt="" loading="lazy"><br>
和分针类似的，2个小时还不足以触发我们的task们，要记得我们的精度总是1秒啊。</p>
<p>那是不是直接把task从时针环换到秒针环就行了呢？</p>
<p>很显然不是，饭要一口一口吃，【小时】和【秒】中间还隔着一个【分钟】，所以先迈一步，放在分钟环上就好，task3是30多分钟的，task4和task5是50多分钟的：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/2h_move.png" alt="" loading="lazy"><br>
这下你发现，现在的情形除了时针从0走到了2，其他的都和0时18分46秒的那个定时器触发流程是完全类似的了。</p>
<p>那我们就加速加速，快进到2时30分，task3从分针环摘下，放到秒针环：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task3_move.png" alt="" loading="lazy"><br>
2时30分45秒，task3触发：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task3.png" alt="" loading="lazy"><br>
2时50分，task4、task5被摘下，放到秒针环：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task45_move.png" alt="" loading="lazy"><br>
2时50分9秒，task4触发：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task4.png" alt="" loading="lazy"><br>
2时50分10秒，task5触发：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/task5.png" alt="" loading="lazy"><br>
好了，到这里时间轮的原理应该演示的很清楚了。</p>
<h1 id="算法分析">算法分析</h1>
<p>和时间堆相比，时间轮很显然是一种空间换时间的算法。</p>
<p>时间堆的单次插入和删除的复杂度都是logn，而时间轮是常数级的，考虑到超时重传等性质的定时器绝大多数不会真的触发，用时间轮做会是一个不错的优化。</p>
<p>时间轮的转动开销平摊到了每次事件循环当中，是可以接受的。</p>
<p>为了缓解空间开销的问题，我们模仿真实的时钟设计了多级时间轮。用<strong>12+60+60</strong>个格子，就表示出了<strong>12*60*60</strong>个时间点，使得空间开销变得可以接受。</p>
<h1 id="源码分析">源码分析</h1>
<p>我们来看看实际的时间轮源码是怎么写的，这里选用了裁剪过的linux内核时间轮代码</p>
<p>先声明源码和上面的演示有哪些不同：</p>
<ul>
<li>计算机里我们用jiffies（可以简化理解为ms）来表示时间，所以精度为1ms</li>
<li>我们受真实时钟的启发设计了多级时间轮，但在实做的时候不会真的按照12+60+60的来做。搞几个轮，每个轮有几个格子都是可以调的。比如我们可以指定1喵秒=123ms，1喵分=456喵秒，1喵时=789喵分，最大超时10喵时，这样一来我们做出了一个【用4个轮子，总共10+789+456+123个格子表示10*789*456*123个ms】的时间轮系统</li>
<li>接上条，为了方便，我们会直接以jiffies的位数来分割轮子，这样就很好的避免了去算余数之类的麻烦且没有必要的操作。在下面的源码中你会看到我们做了3个轮，小轮取jiffies的低18位，也就是说小轮有2^18个格子。中轮和大轮都是2^7个格子，整个时间轮系统最大表示2^(18+7+7)ms</li>
<li>于时间而言我们都是被动的（<s>哲理</s>），我们要做的是在每次事件循环中，去找OS要当前时间，然后把时间轮从上次停下的时间一格一格的转到当前时间，同时执行这个转动过程中摘下的task。也就是说时间轮的精度其实是取决于每次事件循环的延迟，而不总是1ms</li>
</ul>
<p>看代码前先上个示意图，迷糊了可以对着看：<br>
<img src="https://bonboru93.github.io/post-images/time-wheel/source.png" alt="" loading="lazy"></p>
<pre><code class="language-c">#include &quot;timer.h&quot;
#include &quot;list.h&quot;
#include &quot;jiffies.h&quot;

struct timer_list {
    struct pal_list_head entry;
    struct pal_list_head *base_vec;
    unsigned long long expires;
    void (*function)(unsigned long);
    unsigned long data;
};

#define TVN_BITS (7) //中轮和大轮，7位
#define TVR_BITS (18) //小轮，18位
#define TVN_SIZE (1 &lt;&lt; TVN_BITS) //中轮和大轮的格子数
#define TVR_SIZE (1 &lt;&lt; TVR_BITS) //小轮的格子数
#define TVN_MASK (TVN_SIZE - 1)
#define TVR_MASK (TVR_SIZE - 1)

struct tvec { //中轮和大轮
    struct pal_list_head vec[TVN_SIZE]; //链表，放task
};
struct tvec_root { //小轮
    struct pal_list_head vec[TVR_SIZE]; //链表，放task
};
struct tvec_base { //整个时间轮系统
    unsigned long long timer_jiffies; //时间戳
    struct tvec_root tv1; //小轮
    struct tvec tv2; //中轮
    struct tvec tv3; //大轮
};

static inline void init_tvec_t(struct tvec *tv)
{
    int j;
    for (j = 0; j &lt; TVN_SIZE; j++) {
        PAL_INIT_LIST_HEAD(&amp;tv-&gt;vec[j]);
    }
    return;
}
static inline void  init_tvec_root_t(struct tvec_root *tv)
{
    int j;
    for (j = 0; j &lt; TVR_SIZE; j++) {
        PAL_INIT_LIST_HEAD(&amp;tv-&gt;vec[j]);
    }
    return;
}

static struct pal_list_head *get_new_vec_head(struct tvec_base *base,
        uint64_t expires)
{
    int i;
    uint64_t idx = expires - base-&gt;timer_jiffies; //计算超时时间和当前时间相差多少
    struct pal_list_head *vec;
    if (idx &lt; TVR_SIZE) { //如果在小轮的范围内
        i = expires &amp; TVR_MASK; //拿出小轮对应的位数
        vec = base-&gt;tv1.vec + i; //看要放在小轮的第几个位子
    } else if(idx &lt; (1 &lt;&lt; (TVR_BITS + TVN_BITS))) { //如果在中轮的范围内
        i = (expires &gt;&gt; TVR_BITS) &amp; TVN_MASK; //拿出中轮对应的位数
        vec = base-&gt;tv2.vec + i; //看要放在中轮的第几个位子
    } else if((long long)idx &lt; 0) { //如果已经过了
        vec = base-&gt;tv1.vec + ((base-&gt;timer_jiffies + 1) &amp; TVR_MASK); //放进小轮的下一个格子，尽快执行
    } else { //以上都不是，那就是要放在大轮了
        if(idx &gt; 0xffffffffUL) { //不能超过最大范围啊干
            idx = 0xffffffffUL;
            expires = idx + base-&gt;timer_jiffies;
        }
        i = (expires &gt;&gt; (TVR_BITS + TVN_BITS)) &amp; TVN_MASK; //拿出大轮对应的位数
        vec = base-&gt;tv3.vec + i; //看要放在大轮的第几个位子
    }
    return vec;
}

static inline void attach_timer(struct timer_list *timer,
                                struct pal_list_head *new_vec_head) //加一个定时器
{
    pal_list_add_tail(&amp;timer-&gt;entry, new_vec_head);
    timer-&gt;base_vec = new_vec_head;
}

static inline int detach_timer(struct timer_list * timer) //删一个定时器
{
    struct pal_list_head *base_vec;
    base_vec = timer-&gt;base_vec;
    if(!base_vec)
        return 0;
    pal_list_del(&amp;timer-&gt;entry);
    timer-&gt;base_vec = NULL;
    return 1;
}

int __mod_timer(struct tvec_base *host_base, struct timer_list *timer, uint64_t expires) //改超时时间
{
    int ret = 0;
    struct tvec_base *host_base;
    struct pal_list_head *new_vec_head = NULL, *old_vec_head = NULL;

    timer-&gt;expires = expires;
    old_vec_head = timer-&gt;base_vec; //现在挂在哪个格子？
    host_base = &amp;PAL_PER_THREAD(_tvec_base);
    new_vec_head = get_new_vec_head(host_base, expires); //要换到哪个格子下？
    if (new_vec_head == old_vec_head )
        return 0;
    if (old_vec_head) {
        pal_list_del(&amp;timer-&gt;entry);
        ret = 2;
    } else {
        ret = 1;
    }
    attach_timer(timer, new_vec_head); //放上去
    return ret;
}

int mod_timer(struct timer_list *timer, uint64_t expires)
{
    return __mod_timer(timer, expires);
}

int del_timer(struct timer_list *timer)
{
    return detach_timer(timer);
}

static int cascade(struct tvec_base *base, struct tvec *tv, int index) //大轮换中轮，中轮换小轮在这里做
{
    struct pal_list_head *head, *curr;
    struct pal_list_head *new_vec_head, *old_vec_head;
    struct timer_list *tmp;
    old_vec_head = tv-&gt;vec + index; //要从哪个格子里摘task？
    head = old_vec_head;
    curr = head-&gt;next;
    while (curr != head) { //遍历所有的task
        tmp = pal_list_entry(curr, struct timer_list, entry);
        curr = curr-&gt;next;
        new_vec_head = get_new_vec_head(base, tmp-&gt;expires); //要挂到哪个格子下？
        if (new_vec_head != old_vec_head) {
            __pal_list_del(tmp-&gt;entry.prev, tmp-&gt;entry.next);
            attach_timer(tmp, new_vec_head); //放上去
        }
    }
    return index;
}

#define INDEX(N) (base-&gt;timer_jiffies &gt;&gt; (TVR_BITS + N * TVN_BITS)) &amp; TVN_MASK

uint32_t run_timer(int budget, tvec_base *base) //时间轮跑起来，budget意思是一次最多执行多少个task
{
    int index;
    uint32_t events_num = 0;
    uint64_t jiffies_local = jiffies;
    struct timer_list *timer = NULL;
    struct pal_list_head *vec_head = NULL;
    struct pal_list_head *head = NULL;

    while (budget &gt; 0 &amp;&amp; (jiffies_local &gt;= base-&gt;timer_jiffies)) { //有budget，时间轮还没转到当前时间
        index = base-&gt;timer_jiffies &amp; TVR_MASK; //拿出小轮对应的位数
        vec_head = base-&gt;tv1.vec + index; //看是哪个格子
        head = vec_head;

        if ((index == 0) &amp;&amp; ((cascade(base, &amp;base-&gt;tv2, INDEX(0))) == 0)) {
            //如果小轮在第0个格子，说明小轮转了一圈，那么中轮就要走一格，然后把新格子里的task摘下来换到小轮上
            cascade(base, &amp;base-&gt;tv3, INDEX(1));
            //同理，如果中轮在第0个格子，说明中轮转了一圈，那么大轮就要走一格，然后把新格子里的task摘下来换到中轮上
            //这里的INDEX宏就是帮你取各个轮子的位数，应该很好懂
        }
        while (!pal_list_empty(head) &amp;&amp; (budget--)&gt;0) { //把当前格子里有的task都拿出来执行，底下这些链表操作不解释了
            void (*fn)(unsigned long);
            unsigned long data;
            timer = pal_list_entry(head-&gt;next, struct timer_list, entry);
            fn = timer-&gt;function;
            data = timer-&gt;data;
            pal_list_del(&amp;timer-&gt;entry);
            timer-&gt;base_vec = NULL;
            fn(data);
            events_num++;
        }
        if (pal_list_empty(head)) //task都执行完了，小轮再转一格
            base-&gt;timer_jiffies++;
    }
    return events_num;
}

static int init_timers() //初始化，都看得懂
{
    init_tvec_root_t(&amp;tb-&gt;tv1);
    init_tvec_t(&amp;tb-&gt;tv2);
    init_tvec_t(&amp;tb-&gt;tv3);
    tb-&gt;timer_jiffies = jiffies;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node大文件下载oom问题]]></title>
        <id>https://bonboru93.github.io/post/node-da-wen-jian-xia-zai-oom-wen-ti/</id>
        <link href="https://bonboru93.github.io/post/node-da-wen-jian-xia-zai-oom-wen-ti/">
        </link>
        <updated>2020-08-14T07:04:29.000Z</updated>
        <content type="html"><![CDATA[<p>受tornado大文件下载失败case的启发，来测试一下如果用node提供文件下载有什么问题。<br>
<img src="https://bonboru93.github.io/post-images/node-huge-download/oom_code.png" alt="" loading="lazy"><br>
这么写用ab打的话并发一开高就报oom。</p>
<p>查找相关问题，得到：<a href="https://stackoverflow.com/questions/20875314/download-large-file-from-node-http-server-the-server-out-of-memory">https://stackoverflow.com/questions/20875314/download-large-file-from-node-http-server-the-server-out-of-memory</a></p>
<p>res.write是同步的，需要buffer，所以并发高了就oom。</p>
<p>正确的写法：<br>
<img src="https://bonboru93.github.io/post-images/node-huge-download/code_right.png" alt="" loading="lazy"><br>
使用pipe即可。</p>
<p>测试：<br>
<img src="https://bonboru93.github.io/post-images/node-huge-download/ab_tes.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spark上手玩]]></title>
        <id>https://bonboru93.github.io/post/spark-shang-shou-wan/</id>
        <link href="https://bonboru93.github.io/post/spark-shang-shou-wan/">
        </link>
        <updated>2020-08-11T06:13:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="部署方式">部署方式</h1>
<p>参考：<a href="https://blog.csdn.net/Realoyou/article/details/80398424">https://blog.csdn.net/Realoyou/article/details/80398424</a></p>
<p>spark有三种主要的部署方式，local、standalone和yarn。</p>
<ul>
<li>local模式是使用线程来模拟spark的worker，最适合跑测试。</li>
<li>standalone就是自己安排master和worker。</li>
<li>yarn是集群管理，没法拿来做测试。</li>
</ul>
<h1 id="run-example">run-example</h1>
<p>run-example命令后指定要跑的class<br>
注意自带的example都是编译好的已经，直接改example目录下的源码是不生效的，要重新编译后用spark-submit来跑。</p>
<h1 id="docker安装spark">docker安装spark</h1>
<p>使用bitnami提供的docker compose文件：</p>
<figure data-type="image" tabindex="1"><img src="https://bonboru93.github.io/post-images/spark-intro/docker.png" alt="" loading="lazy"></figure>
<p>可以看到他安排了一个master和两个worker，测试用我选择去掉一个。</p>
<p>然后我机器上的docker执行这个compose的话会报错无法创建一个新的子网。因为用compose安排镜像的话默认会创建一个子网和其他的容器隔离开来。在master和worker里都加入【network: bridge】可以挂到默认网桥上去，但是这样改了之后就没法用容器的名字做路由了（看第29行），需要把暴露端口，并且把名字改成宿主机的IP。</p>
<p>这样搞完了之后容器能够起来了，但是报无法移动文件夹相关的错误。查了google和github的issue，没有解决，放弃。</p>
<h1 id="直接local安装">直接local安装</h1>
<p>从spark官网下载程序包，其中的run-example、spark-submit等命令在不添加–master参数的时候默认就以local模式运行，适合做测试。</p>
<p>要注意要求的java版本为1.8，开发机自带的是1.6，使用jumbo安装maven时依赖的也是1.6，要手动安装jumbo上提供的1.8版本，并指定path和java_home。</p>
<h1 id="编译spark提供的example">编译spark提供的example</h1>
<p>从spark官网下载源码包，注意不要从github clone，那个不行。</p>
<p>使用idea打开，选择maven工程，从project structure更换jdk为1.8。</p>
<figure data-type="image" tabindex="2"><img src="https://bonboru93.github.io/post-images/spark-intro/jdk.png" alt="" loading="lazy"></figure>
<p>打开右侧的maven选项卡，下载依赖。</p>
<figure data-type="image" tabindex="3"><img src="https://bonboru93.github.io/post-images/spark-intro/maven.png" alt="" loading="lazy"></figure>
<p>从project structure选择artifacts，加号，jar，from modules</p>
<figure data-type="image" tabindex="4"><img src="https://bonboru93.github.io/post-images/spark-intro/jar.png" alt="" loading="lazy"></figure>
<p>选择example包，main class可以留空</p>
<figure data-type="image" tabindex="5"><img src="https://bonboru93.github.io/post-images/spark-intro/example.png" alt="" loading="lazy"></figure>
<p>build artifact</p>
<figure data-type="image" tabindex="6"><img src="https://bonboru93.github.io/post-images/spark-intro/build.png" alt="" loading="lazy"></figure>
<p>要注意example包中的maven配置依赖父目录下的配置，单独打开example目录作为工程是不行的。</p>
<figure data-type="image" tabindex="7"><img src="https://bonboru93.github.io/post-images/spark-intro/depen.png" alt="" loading="lazy"></figure>
<h1 id="使用spark-submit提交作业">使用spark-submit提交作业</h1>
<p>编译成jar包之后就可以用spark-submit来提交了，先指定class，然后是jar包，最后是参数：</p>
<figure data-type="image" tabindex="8"><img src="https://bonboru93.github.io/post-images/spark-intro/submit.png" alt="" loading="lazy"></figure>
<h1 id="kafka编译问题">kafka编译问题</h1>
<p>在提交kafka相关的example时发现缺少kafka相关的包，首先尝试将依赖全部打入jar包中。</p>
<p>注意到在maven配置中，kafka相关的包配置为provided，而实际执行时却报缺少包，判断spark环境中缺少相关的包。</p>
<p>比如，二次打包过的spark2.2安装包中有kafka-client，而官方的安装包则没有。</p>
<p>首先尝试将provided标签去掉，无效，jar包大小相同。</p>
<p>再尝试在maven配置中启用maven assembly插件，配置jar-with-dependency来把所有的依赖一起打包，还是无效。</p>
<p>再尝试定位报缺少包的代码行，再到maven配置中查找具体的版本号，然后再手动下载jar包放到spark的jars子目录中，解决了两个缺包的问题。</p>
<p>但是之后又出现了在spark core代码包中的scala代码中报的缺包问题，而不是在我们的example包中，这个没有找到解法，放弃了。</p>
<h1 id="基于wordcount进行修改">基于wordcount进行修改</h1>
<p>kafka example的编译问题搞不定，先选择基于wordcount example进行修改，这个example读取的是本地文件，可以正常编译运行，不依赖外部的包。</p>
<p>同时这样有个好处是，万一需要单节点运行，这套程序也可以部署在单机上，读取本地文件。</p>
<figure data-type="image" tabindex="9"><img src="https://bonboru93.github.io/post-images/spark-intro/word.png" alt="" loading="lazy"></figure>
<h1 id="排序问题">排序问题</h1>
<p>google了一下发现spark似乎没有提供按value排序的方法，找到一个workaround是翻转key和value，然后使用sortbykey排序，之后再翻转回来。</p>
<figure data-type="image" tabindex="10"><img src="https://bonboru93.github.io/post-images/spark-intro/sort.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://bonboru93.github.io/post-images/spark-intro/sort2.png" alt="" loading="lazy"></figure>
<h1 id="okhttp使用问题">okhttp使用问题</h1>
<p>为了使用meta提供的restful API向nginx推送数据，这里选择用okhttp库。</p>
<p>首先在maven配置中把依赖加上</p>
<figure data-type="image" tabindex="12"><img src="https://bonboru93.github.io/post-images/spark-intro/okhttp.png" alt="" loading="lazy"></figure>
<p>这里踩到的坑是，spark中已经带了okhttp的库了，但是是v3版，有些api和官方起手式文档中介绍的v4版不同。</p>
<p>比如requestbody的create方法的两个参数顺序是反的，这就导致我在编码的时候如果按v3版的顺序写会被idea提示是过时的方法，但是交上去能运行。而按v4版来写，则交上去报错。</p>
<figure data-type="image" tabindex="13"><img src="https://bonboru93.github.io/post-images/spark-intro/okhttp_bug.png" alt="" loading="lazy"></figure>
<p>尝试把spark自带的v3版jar包删掉，自行下载v4版替换上去，报错。无奈换成v3版来写。</p>
<h1 id="okhttp的密码验证问题">okhttp的密码验证问题</h1>
<p>meta的API是需要basic authentication的，okhttp也自带了相关的代码，参考：https://blog.csdn.net/qq_17775871/article/details/80761961。</p>
<p>但是这个basic authentication的默认行为是首次裸发请求，然后服务器返回401 Unauthorized，再然后客户端再带上用户名密码重新请求一次，okhttp也是这么处理的，但是写好以后发现报错。</p>
<p>无奈抓包看看，发现服务器不是返回401，而是403，所以导致了okhttp没有正确处理。</p>
<figure data-type="image" tabindex="14"><img src="https://bonboru93.github.io/post-images/spark-intro/403.png" alt="" loading="lazy"></figure>
<p>用postman来请求，然后直接复制生成的包头中的authorization字段到header中，问题解决。</p>
<figure data-type="image" tabindex="15"><img src="https://bonboru93.github.io/post-images/spark-intro/auth.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://bonboru93.github.io/post-images/spark-intro/auth2.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《深入理解ES6》读书笔记]]></title>
        <id>https://bonboru93.github.io/post/lesslessshen-ru-li-jie-es6greatergreater-du-shu-bi-ji/</id>
        <link href="https://bonboru93.github.io/post/lesslessshen-ru-li-jie-es6greatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-07-24T03:41:46.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>const的作用域和let相同</p>
</li>
<li>
<p>即使在同一作用域内，声明前也不能使用<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/death.png" alt="" loading="lazy"></p>
</li>
<li>
<p>由于var声明的变量不遵守作用域规定，因此不要将循环变量声明为var，尤其是有闭包的情况下</p>
</li>
<li>
<p>const和几种循环<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/const_loop.png" alt="" loading="lazy"></p>
</li>
<li>
<p>var与全局变量<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/var1.png" alt="" loading="lazy"></p>
</li>
<li>
<p>var、let、const的最佳实践<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/block.png" alt="" loading="lazy"></p>
</li>
<li>
<p>object.is()<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/obj_is.png" alt="" loading="lazy"></p>
</li>
<li>
<p>原型可以修改<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/proto.png" alt="" loading="lazy"></p>
</li>
<li>
<p>各种解构</p>
<p>a. <img src="https://bonboru93.github.io/post-images/es6-learn/de1.png" alt="" loading="lazy"><br>
b. <img src="https://bonboru93.github.io/post-images/es6-learn/de2.png" alt="" loading="lazy"><br>
c. 这种还是别用了<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/de3.png" alt="" loading="lazy"><br>
d. 有点mongodb的嵌套查询的感觉了<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/de4.png" alt="" loading="lazy"><br>
e. 数组<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/de51.png" alt="" loading="lazy"></p>
<p>f. 剩余项<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/de6.png" alt="" loading="lazy"></p>
</li>
<li>
<p>HomeObject<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/home.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/home2.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/home3.png" alt="" loading="lazy"></p>
</li>
<li>
<p>字符串unicode<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/unicode.png" alt="" loading="lazy"></p>
</li>
<li>
<p>字符串查找<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/string.png" alt="" loading="lazy"></p>
</li>
<li>
<p>arguments总是原始值<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/arguments.png" alt="" loading="lazy"></p>
</li>
<li>
<p>函数构造器<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/functor1.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/functor2.png" alt="" loading="lazy"><br>
开始有反射的意思了</p>
</li>
<li>
<p>检查函数是否被作为构造函数进行调用<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/es56.png" alt="" loading="lazy"></p>
</li>
<li>
<p>块级函数<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/block_fun.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/block_fun2.png" alt="" loading="lazy"></p>
</li>
<li>
<p>箭头函数基本属性<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/arrow.png" alt="" loading="lazy"></p>
</li>
<li>
<p>箭头函数带外层函数的arguments闭包<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/arguments_closure.png" alt="" loading="lazy"></p>
</li>
<li>
<p>使用ArrayBuffer和view来使用在v8堆内存之外的空间，和Buffer一样<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/view.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/view2.png" alt="" loading="lazy"></p>
</li>
<li>
<p>类型化数组</p>
<p>从ArrayBuffer创建：<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/arrbuf.png" alt="" loading="lazy"><br>
从普通数组创建：<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/regular_arr.png" alt="" loading="lazy"><br>
和普通数组的公用方法：<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/method3.png" alt="" loading="lazy"><br>
和普通数组的区别：<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/diff1.png" alt="" loading="lazy"><br>
由于类型化数组大小固定，因此下列方法都没有：<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/no_fun.png" alt="" loading="lazy"></p>
</li>
<li>
<p>代理和反射</p>
<p>a. 创建代理<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/proxy.png" alt="" loading="lazy"><br>
b. set陷阱函数<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/trap.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/trap2.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/trap3.png" alt="" loading="lazy"><br>
c. get陷阱函数</p>
<p>……</p>
</li>
<li>
<p>模块的基本概念<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/module.png" alt="" loading="lazy"></p>
</li>
<li>
<p>import的js文件中的代码只会被执行一次<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/import.png" alt="" loading="lazy"></p>
</li>
<li>
<p>import和export必须在顶层<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/export.png" alt="" loading="lazy"></p>
</li>
<li>
<p>import是真正的引用传递，这是为数不多的可以看到引用传递的地方<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/import_name.png" alt="" loading="lazy"></p>
</li>
<li>
<p>export和export default可以同时存在<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/export_default.png" alt="" loading="lazy"></p>
</li>
<li>
<p>模块虽然有自己的作用域，但这并不意味着模块不可以修改全局作用域中已有的对象<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/global.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/es6-learn/global2.png" alt="" loading="lazy"></p>
</li>
<li>
<p>符号，可代替字符串<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/symbol.png" alt="" loading="lazy"></p>
</li>
<li>
<p>使用可计算属性名<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/calc_para.png" alt="" loading="lazy"></p>
</li>
<li>
<p>使用Symbo.for<br>
<img src="https://bonboru93.github.io/post-images/es6-learn/symbol_for.png" alt="" loading="lazy"><br>
为了节省空间？</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node的event和stream]]></title>
        <id>https://bonboru93.github.io/post/node-de-event-he-stream/</id>
        <link href="https://bonboru93.github.io/post/node-de-event-he-stream/">
        </link>
        <updated>2020-07-22T07:13:18.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>EventEmitter是啥<br>
<img src="https://bonboru93.github.io/post-images/node-event/node_definition.png" alt="" loading="lazy"></li>
<li>event的this绑定<br>
<img src="https://bonboru93.github.io/post-images/node-event/this.png" alt="" loading="lazy"></li>
<li>error事件<br>
<img src="https://bonboru93.github.io/post-images/node-event/error.png" alt="" loading="lazy"></li>
<li>listener个数<br>
<img src="https://bonboru93.github.io/post-images/node-event/listen.png" alt="" loading="lazy"></li>
<li>可读流的两种模式<br>
<img src="https://bonboru93.github.io/post-images/node-event/read_stream.png" alt="" loading="lazy"></li>
<li>流的encoding<br>
<img src="https://bonboru93.github.io/post-images/node-event/encoding.png" alt="" loading="lazy"></li>
<li>http的req、res也是流<br>
<img src="https://bonboru93.github.io/post-images/node-event/http.png" alt="" loading="lazy"></li>
<li>链式流<br>
<img src="https://bonboru93.github.io/post-images/node-event/chain.png" alt="" loading="lazy"></li>
<li>标准输入流重定向到文件<br>
<img src="https://bonboru93.github.io/post-images/node-event/redirect.png" alt="" loading="lazy"></li>
<li>使用异步迭代器实现类promise读取流<br>
<img src="https://bonboru93.github.io/post-images/node-event/async.png" alt="" loading="lazy"></li>
<li>使用stream.pipeline一次性完成整条流<br>
<img src="https://bonboru93.github.io/post-images/node-event/line.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用node搞一个4层代理]]></title>
        <id>https://bonboru93.github.io/post/yong-node-gao-yi-ge-4-ceng-dai-li/</id>
        <link href="https://bonboru93.github.io/post/yong-node-gao-yi-ge-4-ceng-dai-li/">
        </link>
        <updated>2020-07-22T06:59:59.000Z</updated>
        <content type="html"><![CDATA[<p>on data写法：</p>
<pre><code class="language-javascript">const net = require('net')
 
 
net.createServer(server_socket =&gt; {
    const client_socket = net.createConnection(22, 'localhost')
    client_socket.on('data', buffer =&gt; server_socket.write(buffer))
    server_socket.on('data', buffer =&gt; client_socket.write(buffer))
}).listen(12345)
</code></pre>
<p>pipe写法：</p>
<pre><code class="language-javascript">const net = require('net')
 
 
net.createServer(server_socket =&gt; {
    const client_socket = net.createConnection(22, 'localhost')
    client_socket.pipe(server_socket)
    server_socket.pipe(client_socket)
}).listen(12345)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gRPC试玩]]></title>
        <id>https://bonboru93.github.io/post/grpc-shi-wan/</id>
        <link href="https://bonboru93.github.io/post/grpc-shi-wan/">
        </link>
        <updated>2020-07-16T09:45:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>protobuf - 接口定义语言<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/protobuf.png" alt="" loading="lazy"><br>
定义消息格式和rpc调用格式</p>
</li>
<li>
<p>传输<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/trans.png" alt="" loading="lazy"></p>
</li>
<li>
<p>一元rpc<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/one1.png" alt="" loading="lazy"></p>
</li>
<li>
<p>服务端流式<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/server_stream.png" alt="" loading="lazy"></p>
</li>
<li>
<p>客户端流式<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/client_stream.png" alt="" loading="lazy"><br>
和常见的on data回调类似</p>
</li>
<li>
<p>启动服务器<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/start1.png" alt="" loading="lazy"></p>
</li>
<li>
<p>客户端调用<br>
<img src="https://bonboru93.github.io/post-images/grpc-learn/call_simple.png" alt="" loading="lazy"></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pm2 性能简单测]]></title>
        <id>https://bonboru93.github.io/post/pm2-xing-neng-jian-dan-ce/</id>
        <link href="https://bonboru93.github.io/post/pm2-xing-neng-jian-dan-ce/">
        </link>
        <updated>2020-07-10T06:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>pm2简要wiki：<a href="https://juejin.im/post/5be406705188256dbb5176f9">https://juejin.im/post/5be406705188256dbb5176f9</a></p>
<pre><code class="language-shell">pm2 start index.js -i 0
</code></pre>
<figure data-type="image" tabindex="1"><img src="pm2_cmd.png" alt="" loading="lazy"></figure>
<pre><code class="language-shell">ab -c 10000 -n 100000
</code></pre>
<table>
<thead>
<tr>
<th>Server</th>
<th>QPS - single instance</th>
<th>QPS - use pm2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello World</td>
<td>5600</td>
<td>6500</td>
</tr>
<tr>
<td>10000 for loop</td>
<td>4600</td>
<td>6500</td>
</tr>
</tbody>
</table>
<p>跑Hello World的话CPU压力很低，主要耗时在event loop，开多进程提升有限。</p>
<p>上了循环以后就不一样了，单进程有明显的性能下降，多进程还能继续维持。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《深入浅出nodejs》读书笔记 ]]></title>
        <id>https://bonboru93.github.io/post/lesslessshen-ru-qian-chu-nodejsgreatergreater-du-shu-bi-ji/</id>
        <link href="https://bonboru93.github.io/post/lesslessshen-ru-qian-chu-nodejsgreatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-07-01T09:51:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>查看内存占用<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/mem.png" alt="" loading="lazy"></p>
</li>
<li>
<p>堆外内存和buffer<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/out1.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/out2.png" alt="" loading="lazy"></p>
</li>
<li>
<p>模块内存<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/module.png" alt="" loading="lazy"></p>
</li>
<li>
<p>几个内存泄漏的例子</p>
<p>a. callback使用不当<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/callback.png" alt="" loading="lazy"><br>
每次请求都会向redis client注册一个回调函数，redis client对象是全局的</p>
<p>b. console.log是异步的，会创建闭包<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/clg.png" alt="" loading="lazy"><br>
这意味着主线程的for循环执行完后会烧掉1e9个闭包</p>
</li>
<li>
<p>使用heapdump排查内存泄漏：<a href="https://www.npmjs.com/package/heapdump">https://www.npmjs.com/package/heapdump</a></p>
</li>
<li>
<p>buffer的内存分配<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/buffer_mem.png" alt="" loading="lazy"></p>
</li>
<li>
<p>buffer拼接引起的乱码<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/cat.png" alt="" loading="lazy"><br>
<strong>解决方法：</strong><br>
a. setEncoding<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/setencoding.png" alt="" loading="lazy"><br>
b. 手动拼接buffer<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/mal_buf.png" alt="" loading="lazy"></p>
</li>
<li>
<p>句柄传递<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/handle.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/handle2.png" alt="" loading="lazy"><br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/handle3.png" alt="" loading="lazy"></p>
</li>
<li>
<p>单元测试，TDD、BDD：https://zhuanlan.zhihu.com/p/91136759<br>
<img src="https://bonboru93.github.io/post-images/deep-node-learn/test.jpg" alt="" loading="lazy"></p>
</li>
</ol>
]]></content>
    </entry>
</feed>